os:putenv("EXOMETER_PACKAGES", "(minimal)"),

MaybeReadFromConfig =
fun ({ok, Content}) ->
        Parts = binary:split(Content, <<"\n">>, [global]),
        %% find only this line which starts with "export APPS="
        [Apps] = [Item || <<"export APPS=\"",Item/binary>> <- Parts],
        %% remove trailing " and conver to string
        binary_to_list(binary:part(Apps, 0, size(Apps) - 1));
    (_) ->
        io:format("WARNING! The configure.out file was not created, using minimal configuration~n"),
        ""
end,

ReadFromConfig =
fun(Path) ->
        case filelib:is_file(Path) of
            true ->
                MaybeReadFromConfig(file:read_file(Path));
            _ ->
                Script = filename:join(["tools", "configure"]),
                os:cmd(Script ++ " with-all without-jingle-sip"),
                MaybeReadFromConfig(file:read_file("configure.out"))
        end
end,

GetEnvApps =
fun() ->
        case os:getenv("APPS") of
            false ->
                ConfigurePath = "configure.out",
                ReadFromConfig(ConfigurePath);
            EnvApps ->
                EnvApps
        end
end,

DevAppsToInclude =
fun() ->
        case os:getenv("DEVNODE") of
            false -> [];
            _ -> [meck]
        end
end,

FirstApps = [kernel, lager],
RequiredApps = [mongooseim, inets, tools, compiler],
AlwaysOptional = [nksip, nkservice, nkpacket, nklib],

EnvApps = GetEnvApps(),

LoadAndStartApps =
fun(Apps) ->
        AlwaysStopped = ordsets:from_list(AlwaysOptional),
        StartedApps = ordsets:subtract(Apps, AlwaysStopped),
        ordsets:to_list(StartedApps)
end,

OnlyLoadApps =
fun(Apps) ->
        AlwaysStopped = ordsets:from_list(AlwaysOptional),
        StoppedApps = ordsets:intersection(Apps, AlwaysStopped),
        OptionalApps = ordsets:to_list(StoppedApps),
        %% If Type = load, the application is only loaded.
        LoadApps = [{App, load} || App <- OptionalApps]
end,

SetupIncludedApps =
fun(Config, EnvApps) ->
        RelxCfg = proplists:get_value(relx, Config),
        {release, Desc, _Apps} = lists:keyfind(release, 1, RelxCfg),
        EnvAppsToInclude = [ list_to_atom(App) || App <- string:tokens(EnvApps, " \n\r") ],
        AppsToIncludeIn = ordsets:from_list(RequiredApps ++ DevAppsToInclude() ++ EnvAppsToInclude),
        Apps = ordsets:subtract(AppsToIncludeIn, ordsets:from_list(FirstApps)),
        StartApps = LoadAndStartApps(Apps),
        LoadApps = OnlyLoadApps(Apps),
        NewReleaseCfg = {release, Desc, FirstApps ++ lists:sort(StartApps ++ LoadApps)},
        NewRelxCfg = lists:keyreplace(release, 1, RelxCfg, NewReleaseCfg),
        lists:keyreplace(relx, 1, Config, {relx, NewRelxCfg})
end,

MaybeFIPSSupport = fun(Config) ->
    code:ensure_loaded(crypto),
    case erlang:function_exported(crypto, info_fips, 0) of
        false ->
            Config;
        _ ->
            io:format("compiling with FIPS mode enabled~n"),
            {erl_opts, ErlOpts} = lists:keyfind(erl_opts, 1, Config),
            NewErlOpts = [{d, fips_mode} | ErlOpts],
            lists:keyreplace(erl_opts, 1, Config, {erl_opts, NewErlOpts})
    end
end,

Config1 = SetupIncludedApps(CONFIG, EnvApps),
MaybeFIPSSupport(Config1).
